// app/chat.tsx
import { useEffect, useRef, useState } from "react";
import {
  Alert,
  FlatList,
  KeyboardAvoidingView,
  Platform,
  Pressable,
  Text,
  TextInput,
  View,
} from "react-native";
import { addPlan } from "../lib/plans";
import { loadProfile, saveProfile, UserProfile } from "../lib/profile";
import { addShoppingItem, extractIngredientsFromAIResponse } from "../lib/shopping";
import { formatSynthesizedMeal, formatSynthesizedWorkout, synthesizeMeal, synthesizeWorkout } from "../lib/synthesis";

type Message = { id: string; text: string; sender: "user" | "ai"; isStreaming?: boolean; originalText?: string };

// ‚úÖ Endpoint Vercel (prod)
const endpoint =
  "https://the-sport-backend-o6wzopx00-matts-projects-43da855b.vercel.app/api/chat";

export default function Chat() {
  const [messages, setMessages] = useState<Message[]>([]);
  const [input, setInput] = useState("");
  const [loading, setLoading] = useState(false);
  const [profile, setProfile] = useState<UserProfile | null>(null);
  const [streamingMessageId, setStreamingMessageId] = useState<string | null>(null);

  const [isAskingProfileQuestions, setIsAskingProfileQuestions] = useState(false);
  const [currentQuestionIndex, setCurrentQuestionIndex] = useState(0);

  // √©tats visuels d'enregistrement
  const [savingWorkout, setSavingWorkout] = useState<"idle" | "saving" | "done">("idle");
  const [savingMeal, setSavingMeal] = useState<"idle" | "saving" | "done">("idle");
  const [addingToShopping, setAddingToShopping] = useState<"idle" | "adding" | "done">("idle");

  const listRef = useRef<FlatList>(null);

  // Fonction pour d√©tecter et extraire les informations du profil depuis une r√©ponse
  const extractProfileInfo = (text: string): Partial<UserProfile> => {
    const lowerText = text.toLowerCase();
    const updates: Partial<UserProfile> = {};

    // D√©tection du niveau de sport
    if (lowerText.includes('d√©butant') || lowerText.includes('debutant')) {
      updates.fitnessLevel = "D√©butant";
    } else if (lowerText.includes('interm√©diaire') || lowerText.includes('intermediaire')) {
      updates.fitnessLevel = "Interm√©diaire";
    } else if (lowerText.includes('avanc√©') || lowerText.includes('avance')) {
      updates.fitnessLevel = "Avanc√©";
    }

    // D√©tection du mat√©riel
    if (lowerText.includes('aucun') || lowerText.includes('rien') || lowerText.includes('pas de mat√©riel')) {
      updates.equipment = "Aucun";
    } else if (lowerText.includes('basique') || lowerText.includes('tapis') || lowerText.includes('√©lastique')) {
      updates.equipment = "Basique";
    } else if (lowerText.includes('complet') || lowerText.includes('salle') || lowerText.includes('halt√®res')) {
      updates.equipment = "Complet";
    }

    // D√©tection des intol√©rances
    if (lowerText.includes('aucune') || lowerText.includes('pas d\'intol√©rance') || lowerText.includes('rien')) {
      updates.intolerances = "Aucune";
    } else {
      const intolerances = [];
      if (lowerText.includes('lactose')) intolerances.push('Lactose');
      if (lowerText.includes('gluten')) intolerances.push('Gluten');
      if (lowerText.includes('fruits √† coque') || lowerText.includes('noix')) intolerances.push('Fruits √† coque');
      if (intolerances.length > 0) {
        updates.intolerances = intolerances.join(', ');
      }
    }

    // D√©tection des limitations
    if (lowerText.includes('aucune') || lowerText.includes('pas de probl√®me') || lowerText.includes('rien')) {
      updates.limitations = "Aucune";
    } else {
      const limitations = [];
      if (lowerText.includes('dos') || lowerText.includes('lombaires')) limitations.push('Probl√®mes de dos');
      if (lowerText.includes('genoux') || lowerText.includes('genou')) limitations.push('Probl√®mes de genoux');
      if (limitations.length > 0) {
        updates.limitations = limitations.join(', ');
      }
    }

    // D√©tection des horaires pr√©f√©r√©s
    if (lowerText.includes('matin')) {
      updates.preferredTime = "Matin";
    } else if (lowerText.includes('midi')) {
      updates.preferredTime = "Midi";
    } else if (lowerText.includes('soir')) {
      updates.preferredTime = "Soir";
    } else if (lowerText.includes('flexible') || lowerText.includes('n\'importe')) {
      updates.preferredTime = "Flexible";
    }

    return updates;
  };

  // Questions compl√©mentaires pour le profil
  const profileQuestions = [
    "Quel est ton niveau de sport actuel ? (d√©butant, interm√©diaire, avanc√©)",
    "Quel mat√©riel de sport as-tu √† disposition ? (aucun, basique, complet)",
    "As-tu des intol√©rances alimentaires ou des allergies ?",
    "Y a-t-il des exercices que tu ne peux pas faire ? (probl√®mes de dos, genoux, etc.)",
    "√Ä quel moment pr√©f√®res-tu faire du sport ? (matin, midi, soir, flexible)"
  ];



  useEffect(() => {
    const initializeChat = async () => {
      try {
        const loadedProfile = await loadProfile();
        setProfile(loadedProfile);
        
        // Initialiser les messages selon le profil
        if (loadedProfile) {
          // V√©rifier si on a des informations compl√©mentaires √† demander
          const needsComplementaryQuestions = !loadedProfile.fitnessLevel || !loadedProfile.equipment || !loadedProfile.intolerances || !loadedProfile.limitations || !loadedProfile.preferredTime;
          
          console.log("Profil charg√©:", loadedProfile);
          console.log("Besoin de questions compl√©mentaires:", needsComplementaryQuestions);
          
          if (needsComplementaryQuestions) {
            setMessages([
              {
                id: "welcome",
                text: "Salut üëã Je suis ton coach IA ! Pour cr√©er un programme parfaitement adapt√© √† tes besoins, j'aimerais te poser quelques questions :",
                sender: "ai",
              },
              {
                id: "question_0",
                text: `1/5 - ${profileQuestions[0]}`,
                sender: "ai",
              }
            ]);
            setIsAskingProfileQuestions(true);
            setCurrentQuestionIndex(0);
          } else {
            // Profil complet, message d'accueil personnalis√©
            const welcomeMessage = loadedProfile.firstName 
              ? `Salut ${loadedProfile.firstName} üëã Je suis ton coach IA. Je connais ton profil et je vais adapter toutes mes r√©ponses √† tes besoins. Pose-moi une question !`
              : "Salut üëã Je suis ton coach IA. Je connais ton profil et je vais adapter toutes mes r√©ponses √† tes besoins. Pose-moi une question !";
            
            setMessages([
              {
                id: "welcome",
                text: welcomeMessage,
                sender: "ai",
              },
            ]);
          }
        } else {
          // Pas de profil, message d'accueil g√©n√©rique
          setMessages([
            {
              id: "welcome",
              text: "Salut üëã Je suis ton coach IA. Commence par faire ton onboarding pour des conseils personnalis√©s !",
              sender: "ai",
            },
          ]);
        }
      } catch (error) {
        console.error("Erreur lors de l'initialisation du chat:", error);
        setMessages([
          {
            id: "error",
            text: "Erreur lors du chargement de ton profil. R√©essaie plus tard !",
            sender: "ai",
          },
        ]);
      }
    };

    initializeChat();
  }, []);

  // Fonction pour traiter une r√©ponse et mettre √† jour le profil
  const handleProfileAnswer = async (answer: string) => {
    if (!profile) return;

    console.log("Traitement de la r√©ponse:", answer);
    
    // Ajouter la r√©ponse de l'utilisateur aux messages
    const userMessage: Message = {
      id: `answer_${currentQuestionIndex}`,
      text: answer,
      sender: "user",
    };
    setMessages(prev => [...prev, userMessage]);
    
    // Extraire les informations du profil depuis la r√©ponse
    const profileUpdates = extractProfileInfo(answer);
    
    // Enregistrer la r√©ponse exacte selon la question actuelle
    const questionKeys = ['fitnessLevel', 'equipment', 'intolerances', 'limitations', 'preferredTime'];
    const currentQuestionKey = questionKeys[currentQuestionIndex];
    
    // Cr√©er ou mettre √† jour les r√©ponses exactes
    const currentChatResponses = profile.chatResponses || {};
    const updatedChatResponses = {
      ...currentChatResponses,
      [currentQuestionKey]: answer
    };
    
    console.log("Informations extraites:", profileUpdates);
    console.log("R√©ponse exacte enregistr√©e:", { [currentQuestionKey]: answer });
    
    try {
      const updatedProfile = { 
        ...profile, 
        ...profileUpdates,
        chatResponses: updatedChatResponses
      };
      await saveProfile(updatedProfile);
      setProfile(updatedProfile);
      
      console.log("Profil mis √† jour:", updatedProfile);
      
      // Passer √† la question suivante
      const nextIndex = currentQuestionIndex + 1;
      setCurrentQuestionIndex(nextIndex);
      
      // Poser la question suivante ou terminer
      setTimeout(() => {
        if (nextIndex < profileQuestions.length) {
          const nextQuestion: Message = {
            id: `question_${nextIndex}`,
            text: `${nextIndex + 1}/5 - ${profileQuestions[nextIndex]}`,
            sender: "ai",
          };
          setMessages(prev => [...prev, nextQuestion]);
        } else {
          // Toutes les questions pos√©es
          setIsAskingProfileQuestions(false);
          const completionMessage: Message = {
            id: "completion",
            text: "Parfait ! J'ai toutes les informations n√©cessaires. Maintenant je peux te donner des conseils parfaitement adapt√©s √† ton profil. Que veux-tu faire ?",
            sender: "ai",
          };
          setMessages(prev => [...prev, completionMessage]);
        }
      }, 500);
      
    } catch (error) {
      console.error("Erreur lors de la sauvegarde du profil:", error);
    }
  } else {
    // Si aucune information n'a √©t√© extraite, poser quand m√™me la question suivante
    const nextIndex = currentQuestionIndex + 1;
    setCurrentQuestionIndex(nextIndex);
    
    setTimeout(() => {
      if (nextIndex < profileQuestions.length) {
        const nextQuestion: Message = {
          id: `question_${nextIndex}`,
          text: `${nextIndex + 1}/5 - ${profileQuestions[nextIndex]}`,
          sender: "ai",
        };
        setMessages(prev => [...prev, nextQuestion]);
      } else {
        // Toutes les questions pos√©es
        setIsAskingProfileQuestions(false);
        const completionMessage: Message = {
          id: "completion",
          text: "Parfait ! J'ai toutes les informations n√©cessaires. Maintenant je peux te donner des conseils parfaitement adapt√©s √† ton profil. Que veux-tu faire ?",
          sender: "ai",
        };
        setMessages(prev => [...prev, completionMessage]);
      }
    }, 500);
  }

  // Fonction pour nettoyer la r√©ponse IA (masquer les balises JSON)
  const cleanAIResponse = (text: string): string => {
    // Supprimer les balises <INGREDIENTS> et leur contenu JSON
    let cleaned = text.replace(/<INGREDIENTS>[\s\S]*?<\/INGREDIENTS>/gi, '');
    
    // Nettoyer les lignes vides multiples
    cleaned = cleaned.replace(/\n\s*\n\s*\n/g, '\n\n');
    
    return cleaned.trim();
  };

  // üöÄ Fonction de streaming simul√© (typewriter effect)
  const simulateStreaming = (fullText: string, messageId: string, originalText?: string) => {
    setStreamingMessageId(messageId);
    
    // Cr√©er le message avec streaming
    const streamingMessage: Message = {
      id: messageId,
      text: "",
      sender: "ai",
      isStreaming: true,
      originalText: originalText // Stocker le texte original avec les balises JSON
    };
    
    setMessages(prev => [...prev, streamingMessage]);
    
    let currentIndex = 0;
    const words = fullText.split(' ');
    
    const streamInterval = setInterval(() => {
      if (currentIndex < words.length) {
        const currentText = words.slice(0, currentIndex + 1).join(' ');
        
        setMessages(prev => 
          prev.map(msg => 
            msg.id === messageId 
              ? { ...msg, text: currentText }
              : msg
          )
        );
        
        currentIndex++;
        
        // Scroll automatique pendant le streaming
        setTimeout(() => listRef.current?.scrollToEnd({ animated: true }), 10);
      } else {
        // Fin du streaming
        clearInterval(streamInterval);
        setStreamingMessageId(null);
        
        setMessages(prev => 
          prev.map(msg => 
            msg.id === messageId 
              ? { ...msg, isStreaming: false }
              : msg
          )
        );
        
        // Scroll final apr√®s la fin du streaming
        setTimeout(() => listRef.current?.scrollToEnd({ animated: true }), 100);
      }
    }, 60); // Vitesse de streaming (60ms par mot - plus rapide)
  };

  const lastAIMessage = () => {
    for (let i = messages.length - 1; i >= 0; i--) {
      if (messages[i].sender === "ai") return messages[i];
    }
    return null;
  };

  async function saveAs(type: "workout" | "meal") {
    const m = lastAIMessage();
    if (!m) {
      Alert.alert("Rien √† enregistrer", "Envoie d'abord une demande au coach üòâ");
      return;
    }
    
    try {
      type === "workout" ? setSavingWorkout("saving") : setSavingMeal("saving");
      
      // üöÄ Utiliser la synth√®se automatique
      const originalText = m.originalText || m.text;
      let synthesizedContent: string;
      let title: string;
      
      if (type === "workout") {
        const synthesized = synthesizeWorkout(originalText);
        synthesizedContent = formatSynthesizedWorkout(synthesized);
        title = synthesized.title || "S√©ance d'entra√Ænement";
      } else {
        const synthesized = synthesizeMeal(originalText);
        synthesizedContent = formatSynthesizedMeal(synthesized);
        title = synthesized.title || "Recette";
      }
      
      await addPlan({ type, title, content: synthesizedContent });
      type === "workout" ? setSavingWorkout("done") : setSavingMeal("done");
      setTimeout(() => (type === "workout" ? setSavingWorkout("idle") : setSavingMeal("idle")), 1200);
    } catch (e) {
      Alert.alert("Erreur", "Impossible d'enregistrer pour le moment.");
      type === "workout" ? setSavingWorkout("idle") : setSavingMeal("idle");
    }
  }

  async function addToShoppingList() {
    const m = lastAIMessage();
    if (!m) {
      Alert.alert("Rien √† ajouter", "Envoie d'abord une demande au coach üòâ");
      return;
    }
    
    try {
      setAddingToShopping("adding");
      
      // üîß Utiliser le texte original (avec balises JSON) pour l'extraction
      const textToExtract = m.originalText || m.text;
      const extractedItems = extractIngredientsFromAIResponse(textToExtract);
      
      if (extractedItems.length === 0) {
        Alert.alert("Aucun ingr√©dient", "Aucun ingr√©dient d√©tect√© dans cette r√©ponse. Demande une recette ou un plan repas !");
        setAddingToShopping("idle");
        return;
      }
      
      // Ajouter chaque ingr√©dient √† la liste de courses
      for (const item of extractedItems) {
        await addShoppingItem({
          ...item,
          source: "Chat IA",
        });
      }
      
      setAddingToShopping("done");
      Alert.alert(
        "Ajout√© √† la liste !",
        `${extractedItems.length} ingr√©dient(s) ajout√©(s) √† votre liste de courses.`,
        [{ text: "Parfait !" }]
      );
      
      setTimeout(() => setAddingToShopping("idle"), 1200);
    } catch (e) {
      Alert.alert("Erreur", "Impossible d'ajouter √† la liste de courses pour le moment.");
      setAddingToShopping("idle");
    }
  }

  async function sendMessage() {
    const content = input.trim();
    if (!content || loading) return;

    // Si on est en train de poser les questions de profil, traiter la r√©ponse
    if (isAskingProfileQuestions) {
      await handleProfileAnswer(content);
      setInput("");
      return; // Ne pas continuer avec le message normal
    }

    const userMsg: Message = {
      id: Date.now().toString(),
      text: content,
      sender: "user",
    };
    setMessages((prev) => [...prev, userMsg]);
    setInput("");
    setLoading(true);

    try {
      // Construire le prompt syst√®me avec toutes les informations du profil
      let systemPrompt = "Tu es un coach sportif & nutrition pour l'app The Sport. " +
        "R√©ponds en fran√ßais, de fa√ßon claire et structur√©e (listes, √©tapes). " +
        "N'effectue pas de conseils m√©dicaux ; oriente vers un professionnel si n√©cessaire.";

      if (profile) {
        systemPrompt += "\n\nINFORMATIONS UTILISATEUR (√† utiliser pour personnaliser tes r√©ponses) :";
        
        // Informations personnelles
        if (profile.firstName) {
          systemPrompt += `\n- Pr√©nom: ${profile.firstName}`;
        }
        if (profile.age) {
          systemPrompt += `\n- √Çge: ${profile.age} ans`;
        }
        if (profile.weight) {
          systemPrompt += `\n- Poids: ${profile.weight} kg`;
        }
        if (profile.height) {
          systemPrompt += `\n- Taille: ${profile.height} cm`;
        }
        
        // Objectifs et pr√©f√©rences
        systemPrompt += `\n- Objectif: ${profile.goal}`;
        systemPrompt += `\n- S√©ances par semaine: ${profile.sessions}`;
        systemPrompt += `\n- R√©gime alimentaire: ${profile.diet}`;
        
        // Informations compl√©mentaires
        if (profile.fitnessLevel) {
          systemPrompt += `\n- Niveau de sport: ${profile.fitnessLevel}`;
        }
        if (profile.equipment) {
          systemPrompt += `\n- Mat√©riel disponible: ${profile.equipment}`;
        }
        if (profile.intolerances) {
          systemPrompt += `\n- Intol√©rances alimentaires: ${profile.intolerances}`;
        }
        if (profile.limitations) {
          systemPrompt += `\n- Limitations physiques: ${profile.limitations}`;
        }
        if (profile.preferredTime) {
          systemPrompt += `\n- Horaires pr√©f√©r√©s: ${profile.preferredTime}`;
        }
        
        systemPrompt += "\n\nIMPORTANT: Adapte TOUJOURS tes r√©ponses √† ces informations. " +
          "Pour les repas, calcule les portions selon l'√¢ge, poids et objectif. " +
          "Pour les exercices, adapte selon le niveau, mat√©riel et limitations. " +
          "N'affiche JAMAIS ces informations dans tes r√©ponses - utilise-les seulement pour personnaliser.";
      }

      systemPrompt += "\n\nFORMAT RECETTES - Utilise TOUJOURS :" +
        "\n<INGREDIENTS>" +
        "\n{\"ingredients\": [{\"name\": \"nom\", \"quantity\": \"qty\", \"unit\": \"unit√©\", \"category\": \"cat√©gorie\"}]}" +
        "\n</INGREDIENTS>" +
        "\n" +
        "Cat√©gories: Fruits, L√©gumes, Prot√©ines, C√©r√©ales, √âpicerie, Laitages, Autres" +
        "\nUnit√©s: g, kg, ml, l, cuill√®res, tasses, pinc√©es, branches, gousses, tranches, unit√©s" +
        "\n" +
        "IMPORTANT: R√©ponses concises et directes. √âvite les r√©p√©titions et les d√©tails superflus.";

      const r = await fetch(endpoint, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          messages: [
            { role: "system", content: systemPrompt },
            ...messages.map((m) => ({
              role: m.sender === "user" ? "user" : "assistant",
              content: m.text,
            })),
            { role: "user", content },
          ],
        }),
      });

      const ct = r.headers.get("content-type") || "";
      const text = await r.text();
      if (!r.ok) throw new Error(`HTTP ${r.status} - ${text.slice(0, 220)}`);
      if (!ct.includes("application/json"))
        throw new Error(`R√©ponse non-JSON: ${text.slice(0, 220)}`);

      const data = JSON.parse(text);
      const replyText = data.reply?.toString() || "‚ö†Ô∏è Pas de r√©ponse re√ßue.";

      // üöÄ Utiliser le streaming simul√© au lieu d'ajouter directement
      const messageId = (Date.now() + 1).toString();
      const cleanedText = cleanAIResponse(replyText); // Nettoyer AVANT le streaming
      simulateStreaming(cleanedText, messageId, replyText); // Passer le texte original
    } catch (e: any) {
      const errorText = "‚ùå Erreur serveur: " +
        (e?.message || "inconnue") +
        "\n(Astuce: v√©rifie l'URL de l'API et ta cl√© OpenAI sur Vercel)";
      
      setMessages((prev) => [
        ...prev,
        {
          id: (Date.now() + 2).toString(),
          text: errorText,
          sender: "ai",
          originalText: errorText, // M√™me texte pour les erreurs
        },
      ]);
    } finally {
      setLoading(false);
      setTimeout(() => listRef.current?.scrollToEnd({ animated: true }), 50);
    }
  }

  return (
    <KeyboardAvoidingView
      style={{ flex: 1, backgroundColor: "#000" }}
      behavior={Platform.OS === "ios" ? "padding" : undefined}
      keyboardVerticalOffset={Platform.OS === "ios" ? 80 : 0}
    >
      <View style={{ flex: 1, paddingTop: 60, paddingHorizontal: 12 }}>
        <Text style={{ color: "#fff", fontSize: 22, fontWeight: "800", marginBottom: 12 }}>
          üí¨ Ton coach IA
        </Text>

        {profile && (
          <Text style={{ color: "#aaa", marginBottom: 8 }}>
            Profil: {profile.goal} ‚Ä¢ {profile.sessions} s√©ances/sem ‚Ä¢ {profile.diet}
            {profile.weight && ` ‚Ä¢ ${profile.weight}kg`}
            {profile.age && ` ‚Ä¢ ${profile.age}ans`}
            {profile.fitnessLevel && ` ‚Ä¢ ${profile.fitnessLevel}`}
            {profile.equipment && ` ‚Ä¢ ${profile.equipment}`}
          </Text>
        )}

        {streamingMessageId && (
          <View style={{ 
            backgroundColor: "#1a1a1a", 
            padding: 8, 
            borderRadius: 8, 
            marginBottom: 8,
            flexDirection: "row",
            alignItems: "center"
          }}>
            <Text style={{ color: "#0070F3", marginRight: 8 }}>ü§ñ</Text>
            <Text style={{ color: "#aaa", fontSize: 12 }}>
              G√©n√©ration en cours...
            </Text>
          </View>
        )}

        <FlatList
          ref={listRef}
          data={messages}
          keyExtractor={(item) => item.id}
          contentContainerStyle={{ paddingBottom: 12 }}
          renderItem={({ item }) => (
            <View>
              <View
                style={{
                  alignSelf: item.sender === "user" ? "flex-end" : "flex-start",
                  backgroundColor: item.sender === "user" ? "#0070F3" : "#1b1b1b",
                  marginVertical: 6,
                  padding: 12,
                  borderRadius: 12,
                  maxWidth: "78%",
                }}
              >
                <Text style={{ color: "#fff", lineHeight: 20 }}>
                  {item.sender === "ai" && !item.isStreaming ? cleanAIResponse(item.text) : item.text}
                  {item.isStreaming && <Text style={{ color: "#0070F3" }}>‚ñã</Text>}
                </Text>
              </View>
              

            </View>
          )}
          onContentSizeChange={() => listRef.current?.scrollToEnd({ animated: true })}
        />

        {/* Barre d'action avec feedback visuel */}
        <View style={{ flexDirection: "row", gap: 8, marginBottom: 8 }}>
          <Pressable
            onPress={() => saveAs("workout")}
            style={({ pressed }) => ({
              flex: 1,
              backgroundColor:
                savingWorkout === "saving"
                  ? "#0a3a78"
                  : savingWorkout === "done"
                  ? "#0c5bd6"
                  : pressed
                  ? "#222"
                  : "#1b1b1b",
              borderWidth: 1,
              borderColor: "#2a2a2a",
              paddingVertical: 10,
              borderRadius: 10,
              alignItems: "center",
            })}
          >
            <Text style={{ color: "#fff", fontWeight: "700" }}>
              {savingWorkout === "saving"
                ? "Enregistrement‚Ä¶"
                : savingWorkout === "done"
                ? "Enregistr√© ‚úÖ"
                : "Enregistrer s√©ance üèãÔ∏è"}
            </Text>
          </Pressable>

          <Pressable
            onPress={() => saveAs("meal")}
            style={({ pressed }) => ({
              flex: 1,
              backgroundColor:
                savingMeal === "saving"
                  ? "#0a3a78"
                  : savingMeal === "done"
                  ? "#0c5bd6"
                  : pressed
                  ? "#222"
                  : "#1b1b1b",
              borderWidth: 1,
              borderColor: "#2a2a2a",
              paddingVertical: 10,
              borderRadius: 10,
              alignItems: "center",
            })}
          >
            <Text style={{ color: "#fff", fontWeight: "700" }}>
              {savingMeal === "saving"
                ? "Enregistrement‚Ä¶"
                : savingMeal === "done"
                ? "Enregistr√© ‚úÖ"
                : "Enregistrer repas üçΩÔ∏è"}
            </Text>
          </Pressable>
        </View>

        {/* Bouton liste de courses */}
        <View style={{ marginBottom: 8 }}>
          <Pressable
            onPress={addToShoppingList}
            style={({ pressed }) => ({
              backgroundColor:
                addingToShopping === "adding"
                  ? "#0a3a78"
                  : addingToShopping === "done"
                  ? "#0c5bd6"
                  : pressed
                  ? "#222"
                  : "#1b1b1b",
              borderWidth: 1,
              borderColor: "#2a2a2a",
              paddingVertical: 12,
              borderRadius: 10,
              alignItems: "center",
            })}
          >
            <Text style={{ color: "#fff", fontWeight: "700" }}>
              {addingToShopping === "adding"
                ? "Ajout en cours‚Ä¶"
                : addingToShopping === "done"
                ? "Ajout√© √† la liste ‚úÖ"
                : "üõí Ajouter √† la liste de courses"}
            </Text>
          </Pressable>
        </View>

        {/* Zone de saisie */}
        <View style={{ flexDirection: "row", alignItems: "center", paddingBottom: 12 }}>
          <TextInput
            value={input}
            onChangeText={setInput}
            placeholder={loading ? "ü§ñ G√©n√©ration en cours..." : "√âcris ton message..."}
            editable={!loading}
            placeholderTextColor="#777"
            style={{
              flex: 1,
              backgroundColor: "#111",
              color: "#fff",
              padding: 12,
              borderRadius: 12,
              marginRight: 8,
            }}
            onSubmitEditing={sendMessage}
            returnKeyType="send"
          />
          <Pressable
            onPress={sendMessage}
            disabled={loading}
            style={({ pressed }) => ({
              backgroundColor: loading ? "#333" : pressed ? "#0057c0" : "#0070F3",
              paddingVertical: 12,
              paddingHorizontal: 18,
              borderRadius: 12,
            })}
          >
            <Text style={{ color: "#fff", fontWeight: "700" }}>{loading ? "‚Ä¶" : "Envoyer"}</Text>
          </Pressable>
        </View>
      </View>
    </KeyboardAvoidingView>
  );
}








